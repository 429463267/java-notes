# java 自学笔记、冷知识

---

**java 自学笔记、冷知识**


> 1-随机数0~99的两种生成方式：

int x=(int) (Math.random()*100);

int y=new Random().nextInt(100);    //推荐

> 2-Scanner 输入两种方式：

Scanner sc=new Scanner(System.in);
String s1=sc.nextLine();
sc.close();

> 3 read（）方法我知道是读一个字节，如果用while循环读取的话，为什么他第二次循环的时候就自动read后面的字节了呢？不知道内存里是怎么分配的，解释如下：

如果用while循环读取的话，为什么他第二次循环的时候就自动read后面的字节了呢？

解答：要解释为什么会自动读取后面的字节，首先需要了解大体上文件在硬盘物理结构上的存取方式。这涉及到很多很多专业知识，比如文件系统等，简单来说就是，当你保存文件的时候步骤基本上是：操作系统首先在DIR区中找到空区写入文件名、大小和创建时间等相应信息，然后在Data区找到闲置空间将文件按照簇尽可能找到连续的数据区，依次将写入流从头开始将每个字节进行顺序保存。

当要进行文件的读取时，Java封装的FileInputStream.read方法也会调用操作系统的API依次读取这些数据。在读取文件数据的时候必须是顺序的，不可能说先读取第一个字节，后读取倒数第二个字节。循环读取的时候就read方法将读取的位置++，因此造成每次read都是顺序读取后面的字节，直到遇到文件末尾标记。
另外说一下读取出来的每一个字节在你这个程序中的保存方式：
文件流FileInputStream的读取是单向的，也就是说从第一个字节到最后一个字节。如果文件总共|1|2|3|4|5|个字节，那么文件读取的顺序肯定是12345，假设当前已经读到3，那么接下来要么你停止读取，要么你读取4，不可能再回头读取2和1，也不能直接去读取5。通过in.read()读取出来的数据是个临时变量，java会自动在堆中为它分配一个内存空间，但是当fis.read()执行结束后，垃圾回收器gc会立刻将其删除，因此在这个程序中，读取出来的文件其实只保存了最后一个字节，这个字节放在b变量中。如果你想保存整个文件数据，你可以建立一个与文件长度等长的byte数组。
http://blog.csdn.net/liangruimi/article/details/44856843###;

> 4 InputStream read（）方法详解

在计算机中，所有的文件都是以二进制的形式存储的，换句话说，每个文件不管是什么类型，在计算机中的形式都是一串0和1。而read()方法在读的时候是每次读取8个二进制位，这8个0或1就是我们所谓的一个byte（字节）。在这里通常容易产生的疑问就是将字节和字符混为一谈。无论在什么语言什么系统中，只要它符合当今世界对于计算机技术的主流定义，那么一个byte就是8个二进制位。而字符则不同，字符是与人为定义的编码规则相关的，一个字符的大小（也就是其所占的二进制位）是由编码规则决定的，比如在GBK编码中一个汉字用两个字节表示，而在utf-8中，一个汉字由3到4个字节表示。言归正传，既然一个byte表示8个二进制位，那么这8个二进制位就是一个0-255之间的十进制数字，实际上在Java中，byte就是一个0-255之间的整数，而将从文件中读取的二进制转化成十进制这一过程是由read()方法完成的。 
　　也就是说，read()这个方法完成的事情就是从数据源中读取8个二进制位，并将这8个0或1转换成十进制的整数，然后将其返回。 
https://blog.csdn.net/u010276761/article/details/52692962
https://blog.csdn.net/Amo_te_ama_me/article/details/40587997



　　

